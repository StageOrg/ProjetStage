"use client";
import { useState } from "react";

// Donn√©es simul√©es
const fakeProfesseurs = [
  { id: 1, nom: "Kossi", prenom: "Jean", titre: "Docteur", ues: ["Maths", "Physique"] },
  { id: 2, nom: "Adjo", prenom: "Marie", titre: "Professeur", ues: ["Informatique"] },
  { id: 3, nom: "Tchalla", prenom: "Koffi", titre: "Assistant", ues: [] },
];

// Liste des UEs disponibles (tu remplaceras par ton API)
const allUEs = ["Maths", "Physique", "Informatique", "Chimie", "Biologie"];

export default function AffectationUE() {
  const [professeurs, setProfesseurs] = useState(fakeProfesseurs);
  const [selectedProf, setSelectedProf] = useState(null);
  const [showUESelector, setShowUESelector] = useState(false);
  const [selectedUEs, setSelectedUEs] = useState([]);

  const handleSelectProf = (prof) => {
    setSelectedProf(prof);
    setShowUESelector(false);
    setSelectedUEs([]);
  };

  const handleToggleUE = (ue) => {
    if (selectedUEs.includes(ue)) {
      setSelectedUEs(selectedUEs.filter((item) => item !== ue));
    } else {
      setSelectedUEs([...selectedUEs, ue]);
    }
  };

  const handleAddUE = () => {
    setShowUESelector(true);
  };

  const handleValidate = () => {
    if (selectedProf && selectedUEs.length > 0) {
      setProfesseurs((prev) =>
        prev.map((p) =>
          p.id === selectedProf.id
            ? { ...p, ues: [...p.ues, ...selectedUEs] }
            : p
        )
      );
      setSelectedProf((prev) => ({
        ...prev,
        ues: [...prev.ues, ...selectedUEs],
      }));
      setSelectedUEs([]);
      setShowUESelector(false);
    }
  };

  return (
    <div className="p-6">
      <h2 className="text-xl font-bold mb-6">Affectation des UEs aux professeurs</h2>

      <div className="grid grid-cols-2 gap-6">
        {/* Colonne gauche : liste des professeurs */}
        <div>
          <h3 className="font-semibold mb-2">Liste des professeurs</h3>
          <table className="w-full border-collapse border border-gray-300">
            <thead>
              <tr className="bg-gray-200">
                <th className="border p-2">Nom</th>
                <th className="border p-2">Pr√©nom</th>
                <th className="border p-2">Titre</th>
              </tr>
            </thead>
            <tbody>
              {professeurs.map((prof) => (
                <tr
                  key={prof.id}
                  className={`cursor-pointer hover:bg-gray-100 ${
                    selectedProf?.id === prof.id ? "bg-blue-100" : ""
                  }`}
                  onClick={() => handleSelectProf(prof)}
                >
                  <td className="border p-2">{prof.nom}</td>
                  <td className="border p-2">{prof.prenom}</td>
                  <td className="border p-2">{prof.titre}</td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>

        {/* Colonne droite : d√©tails du prof s√©lectionn√© */}
        <div>
          {selectedProf ? (
            <div>
              <h3 className="text-lg font-semibold mb-4">
                UEs de {selectedProf.titre} {selectedProf.nom} {selectedProf.prenom}
              </h3>
              <button
                onClick={handleAddUE}
                className="bg-blue-600 text-white px-4 py-2 rounded mb-4"
              >
                ‚ûï Affecter une UE
              </button>

              {/* Liste des UEs d√©j√† affect√©es */}
              {selectedProf.ues.length > 0 ? (
                <ul className="list-disc ml-6 mb-4">
                  {selectedProf.ues.map((ue, index) => (
                    <li key={index}>{ue}</li>
                  ))}
                </ul>
              ) : (
                <p className="text-gray-500 mb-4">Aucune UE affect√©e.</p>
              )}

              {/* S√©lecteur d‚ÄôUEs */}
              {showUESelector && (
                <div className="p-4 border rounded bg-gray-50">
                  <h4 className="font-medium mb-2">S√©lectionnez les UEs √† affecter :</h4>
                  <table className="w-full border-collapse border border-gray-300 mb-4">
                    <thead>
                      <tr className="bg-gray-200">
                        <th className="border p-2">Choisir</th>
                        <th className="border p-2">Nom de l‚ÄôUE</th>
                      </tr>
                    </thead>
                    <tbody>
                      {allUEs.map((ue) => (
                        <tr key={ue}>
                          <td className="border p-2 text-center">
                            <input
                              type="checkbox"
                              checked={selectedUEs.includes(ue)}
                              onChange={() => handleToggleUE(ue)}
                            />
                          </td>
                          <td className="border p-2">{ue}</td>
                        </tr>
                      ))}
                    </tbody>
                  </table>

                  <button
                    onClick={handleValidate}
                    className="bg-green-600 text-white px-4 py-2 rounded"
                  >
                    ‚úÖ Valider
                  </button>
                </div>
              )}
            </div>
          ) : (
            <p className="text-gray-500">S√©lectionnez un professeur √† gauche.</p>
          )}
        </div>
      </div>
    </div>
  );
}





"use client";

import { useState, useEffect } from "react";
import UEService from "@/services/ueService";

export default function GestionUEs() {
  const [ues, setUes] = useState([]);
  const [loading, setLoading] = useState(true);
  const [editingUE, setEditingUE] = useState(null);
  const [newUEData, setNewUEData] = useState({ code: "", libelle: "" });

  // Charger les UEs
  useEffect(() => {
    fetchUEs();
  }, []);

  const fetchUEs = async () => {
    try {
      setLoading(true);
      const data = await UEService.getAllUE();
      setUes(data);
    } catch (error) {
      console.error("Erreur lors du chargement des UEs :", error);
    } finally {
      setLoading(false);
    }
  };

  // Ajouter une nouvelle UE
  const handleAddUE = async () => {
    const code = prompt("Code de la nouvelle UE :");
    const libelle = prompt("Libell√© de la nouvelle UE :");
    if (!code || !libelle) return;

    try {
      const createdUE = await UEService.creerUE({ code, libelle });
      setUes((prev) => [...prev, createdUE]);
    } catch (error) {
      console.error("Erreur lors de la cr√©ation :", error);
    }
  };

  // √âditer une UE
  const handleEditUE = (ue) => {
    setEditingUE(ue);
    setNewUEData({ code: ue.code, libelle: ue.libelle });
  };

  // Valider la modification
  const handleUpdateUE = async () => {
    if (!newUEData.code.trim() || !newUEData.libelle.trim()) return;
    try {
      await UEService.updateUE(editingUE.id, newUEData);
      setUes((prev) =>
        prev.map((ue) =>
          ue.id === editingUE.id ? { ...ue, ...newUEData } : ue
        )
      );
      setEditingUE(null);
      setNewUEData({ code: "", libelle: "" });
    } catch (error) {
      console.error("Erreur lors de la modification :", error);
    }
  };

  // Supprimer une UE
  const handleDeleteUE = async (ue) => {
    if (!confirm(`Supprimer l'UE "${ue.libelle}" ?`)) return;
    try {
      await UEService.deleteUE(ue.id);
      setUes((prev) => prev.filter((u) => u.id !== ue.id));
    } catch (error) {
      console.error("Erreur lors de la suppression :", error);
    }
  };

  if (loading) return <p>Chargement des UEs...</p>;

  return (
    <div className="p-6">
      <h2 className="text-xl font-bold mb-4">Gestion des UEs</h2>

      <button
        onClick={handleAddUE}
        className="bg-blue-600 text-white px-4 py-2 rounded mb-4"
      >
        ‚ûï Ajouter une UE
      </button>

      <table className="w-full border-collapse border border-gray-300">
        <thead>
          <tr className="bg-gray-200">
            <th className="border p-2">Code</th>
            <th className="border p-2">Libell√©</th>
            <th className="border p-2">Actions</th>
          </tr>
        </thead>
        <tbody>
          {ues.map((ue) => (
            <tr key={ue.id} className="hover:bg-gray-100">
              <td className="border p-2">
                {editingUE?.id === ue.id ? (
                  <input
                    value={newUEData.code}
                    onChange={(e) =>
                      setNewUEData((prev) => ({ ...prev, code: e.target.value }))
                    }
                    className="border p-1 rounded w-full"
                  />
                ) : (
                  ue.code
                )}
              </td>
              <td className="border p-2">
                {editingUE?.id === ue.id ? (
                  <input
                    value={newUEData.libelle}
                    onChange={(e) =>
                      setNewUEData((prev) => ({ ...prev, libelle: e.target.value }))
                    }
                    className="border p-1 rounded w-full"
                  />
                ) : (
                  ue.libelle
                )}
              </td>
              <td className="border p-2 flex gap-2">
                {editingUE?.id === ue.id ? (
                  <>
                    <button
                      onClick={handleUpdateUE}
                      className="bg-green-600 text-white px-2 py-1 rounded"
                    >
                      üíæ
                    </button>
                    <button
                      onClick={() => setEditingUE(null)}
                      className="bg-gray-400 text-white px-2 py-1 rounded"
                    >
                      ‚ùå
                    </button>
                  </>
                ) : (
                  <>
                    <button
                      onClick={() => handleEditUE(ue)}
                      className="bg-yellow-500 text-white px-2 py-1 rounded"
                    >
                      ‚úèÔ∏è
                    </button>
                    <button
                      onClick={() => handleDeleteUE(ue)}
                      className="bg-red-600 text-white px-2 py-1 rounded"
                    >
                      üóëÔ∏è
                    </button>
                  </>
                )}
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}


// frontend/services/authService.js
import api from "./api"; 
const TokenStorage = {
  getAccess: () => localStorage.getItem("access"),
  getRefresh: () => localStorage.getItem("refresh"),
  setTokens: ({ access, refresh }) => {
    if (access) localStorage.setItem("access", access);
    if (refresh) localStorage.setItem("refresh", refresh);
  },
  clear: () => {
    localStorage.removeItem("access");
    localStorage.removeItem("refresh");
  },
};

/* ---------------------------
  Interceptor : ajoute Authorization automatiquement
  et g√®re le refresh quand on re√ßoit 401.
---------------------------- */
let isRefreshing = false;
let refreshQueue = []; // queue des requ√™tes en attendant le refresh

function processQueue(error, token = null) {
  refreshQueue.forEach(prom => {
    if (error) prom.reject(error);
    else prom.resolve(token);
  });
  refreshQueue = [];
}

api.interceptors.request.use((config) => {
  const token = TokenStorage.getAccess();
  if (token) config.headers.Authorization = `Bearer ${token}`;
  return config;
}, (error) => Promise.reject(error));

api.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;
    // Si 401 et que ce n'est pas la requ√™te refresh elle-m√™me
    if (error.response && error.response.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;
      const refreshToken = TokenStorage.getRefresh();
      if (!refreshToken) {
        TokenStorage.clear();
        return Promise.reject(error);
      }

      if (isRefreshing) {
        // attendre la fin d'un refresh en cours
        return new Promise((resolve, reject) => {
          refreshQueue.push({ resolve, reject });
        }).then((token) => {
          originalRequest.headers.Authorization = `Bearer ${token}`;
          return api(originalRequest);
        }).catch(err => Promise.reject(err));
      }

      isRefreshing = true;
      try {
        const res = await api.post("token/refresh/", { refresh: refreshToken });
        const newAccess = res.data.access;
        TokenStorage.setTokens({ access: newAccess });
        processQueue(null, newAccess);
        originalRequest.headers.Authorization = `Bearer ${newAccess}`;
        return api(originalRequest);
      } catch (refreshError) {
        processQueue(refreshError, null);
        TokenStorage.clear();
        return Promise.reject(refreshError);
      } finally {
        isRefreshing = false;
      }
    }

    return Promise.reject(error);
  }
);

/* ---------------------------
  Fonctions export√©es
---------------------------- */

export const authAPI = {
  /**
   * login(username, password)
   * attend { access, refresh } en retour
   */
  login: async (username, password) => {
    const res = await api.post("auth/login/", { username, password });
    const { access, refresh, user } = res.data;
    TokenStorage.setTokens({ access, refresh });
    return { access, refresh, user };
  },

  /**
   * register(userPayload)
   * envoie toutes les donn√©es d'inscription (utilisateur + profil) √† l'endpoint /auth/register/
   * ex: { username, email, password, role, num_carte, date_naiss, ... }
   */
  register: async (userPayload) => {
    try {
      const res = await api.post("auth/register/", userPayload);
      return res.data;
    } catch (error) {
      console.error("Erreur lors de l'inscription :", error);
      throw error;
    }
  },

  /**
   * refresh()
   * rafra√Æchit manuellement le token si besoin
   */
  refresh: async () => {
    const refresh = TokenStorage.getRefresh();
    if (!refresh) throw new Error("Pas de refresh token");
    const res = await api.post("token/refresh/", { refresh });
    const { access } = res.data;
    TokenStorage.setTokens({ access });
    return res.data;
  },

  /**
   * logout()
   * - supprime les tokens c√¥t√© client
   * - (optionnel) appeler un endpoint pour invalider le refresh c√¥t√© backend si tu l'as impl√©ment√©
   */
  logout: async (callBackendInvalidate = false) => {
    const refresh = TokenStorage.getRefresh();
    TokenStorage.clear();
    if (callBackendInvalidate && refresh) {
      try {
        await api.post("auth/logout/", { refresh });
      } catch (e) {
        // ignore
      }
    }
  },

  /**
   * getProfile()
   * r√©cup√®re /utilisateurs/me/ 
   */
  getProfile: async () => {
    const res = await api.get("utilisateurs/me/");
    return res.data;
  },

  /**
   * utilitaire pour r√©cup√©rer l'api instance (utile si tu veux faire d'autres appels)
   */
  apiInstance: () => api,
};

/* Optionnel : auto-refresh p√©riodique (ex: avant expiration)
   Tu peux mettre un setInterval pour appeler refresh() si tu veux.
*/
export default authAPI;